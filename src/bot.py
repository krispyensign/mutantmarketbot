from dataclasses import dataclass
from datetime import datetime  # noqa: D100
import logging
from time import sleep
import pandas as pd
import v20  # type: ignore

from backtest import backtest
from core.config import (
    BACKTEST_COUNT,
    BACKTEST_INTERVAL,
    GRANULARITY,
    OPTIMISTIC,
    REFRESH_RATE,
    TAKE_PROFIT_MULTIPLIER,
    WMA_PERIOD,
)
from core.kernel import kernel
from reporting import report
from exchange import (
    close_order,
    get_open_trades,
    getOandaOHLC,
    place_order,
)

logger = logging.getLogger("bot")


class Record:
    """Record class."""

    ATR: float
    take_profit: float
    wma: float
    signal: int
    trigger: int

    def __init__(self, df: pd.DataFrame):
        """Initialize a Record object."""
        self.ATR = df["ATR"].iloc[-1]
        self.take_profit = (
            df["entry_price"].iloc[-1] + df["atr"].iloc[-1] * TAKE_PROFIT_MULTIPLIER
        )
        self.wma = df["wma"].iloc[-1]
        self.signal = df["signal"].iloc[-1]
        self.trigger = df["trigger"].iloc[-1]


def bot(token: str, account_id: str, instrument: str, amount: float) -> None:
    """Bot that trades on Oanda.

    This function trades on Oanda using the Oanda API. It places market orders based on the
    trading signals generated by the kernel function.  It closes the trade when the trigger is -1.

    Parameters
    ----------
    token : str
        The Oanda API token.
    account_id : str
        The Oanda account ID.
    instrument : str
        The instrument to trade.
    amount : float | None
        The amount to trade. If None, the bot will calculate the amount based
        on the current balance.

    """
    df: pd.DataFrame
    app_start_time = datetime.now()
    signal_conf = backtest(
        instrument=instrument,
        token=token,
    )
    last_backtest_time = datetime.now()
    logger.info("starting bot.")
    
    ctx = v20.Context("api-fxpractice.oanda.com", token=token)
    trade_id = -1
    while True:
        run_start_time = datetime.now()
        try:
            trade_id = get_open_trades(ctx, account_id)
            df = getOandaOHLC(
                ctx, instrument, count=BACKTEST_COUNT, granularity=GRANULARITY
            )
        except Exception as err:
            logger.error(err)
            trade_id = -1
            sleep(5)
            continue

        kernel(
            df,
            wma_period=WMA_PERIOD,
            optimistic=OPTIMISTIC,
            signal_buy_column=signal_conf.signal_buy_column,
            signal_exit_column=signal_conf.signal_exit_column,
            source_column=signal_conf.source_column,
        )
        rec = Record(df)

        if rec.trigger == 1 and trade_id == -1:
            try:
                trade_id = place_order(
                    ctx,
                    account_id,
                    instrument,
                    amount,
                    take_profit=rec.take_profit,
                    trailing_distance=rec.ATR,
                    stop_loss=rec.wma,
                )
                continue
            except Exception as err:
                logger.error(err)
                trade_id = -1
                sleep(1)
                continue

        if rec.trigger != 1 and rec.signal == 0 and trade_id != -1:
            try:
                close_order(ctx, account_id, trade_id)
            except Exception as err:
                logger.error(err)

        # print the results
        run_end_time = datetime.now()
        report(df)
        logger.info(f"columns used: {signal_conf}")
        logger.info(f"trade id: {trade_id}")
        logger.info(f"run interval: {run_end_time - run_start_time}")
        logger.info("up time: %s", (run_end_time - app_start_time))
        logger.info("last run time: %s", run_end_time.strftime("%Y-%m-%d %H:%M:%S"))

        # backtest if needed
        if (
            trade_id == -1
            and (run_end_time - last_backtest_time).total_seconds() > BACKTEST_INTERVAL
        ):
            signal_conf = backtest(
                instrument=instrument,
                token=token,
            )
            last_backtest_time = datetime.now()

        sleep(REFRESH_RATE)
