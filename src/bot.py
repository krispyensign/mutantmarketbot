from datetime import datetime  # noqa: D100
import logging
from time import sleep
import pandas as pd
import v20  # type: ignore

from backtest import backtest
from constants import (
    BACKTEST_COUNT,
    BACKTEST_INTERVAL,
    GRANULARITY,
    OPTIMISTIC,
    REFRESH_RATE,
    TAKE_PROFIT_MULTIPLIER,
    WMA_PERIOD,
)
from core import kernel
from reporting import report
from exchange import (
    close_order,
    get_open_trades,
    getOandaOHLC,
    place_order,
)

logger = logging.getLogger("main.py")

def bot(  # noqa: C901, PLR0915
    token: str, account_id: str, instrument: str, amount: float
) -> None:
    """Bot that trades on Oanda.

    This function trades on Oanda using the Oanda API. It places market orders based on the
    trading signals generated by the kernel function.  It closes the trade when the trigger is -1.

    Parameters
    ----------
    token : str
        The Oanda API token.
    account_id : str
        The Oanda account ID.
    instrument : str
        The instrument to trade.
    amount : float | None
        The amount to trade. If None, the bot will calculate the amount based
        on the current balance.

    """
    df: pd.DataFrame
    start_time = datetime.now()
    columns = backtest(
        instrument=instrument,
        token=token,
    )
    source_column = columns[0]
    signal_buy_column = columns[1]
    signal_exit_column = columns[2]
    last_backtest_time = datetime.now()
    logger.info("starting bot")
    logger.info("time now: %s", start_time.strftime("%Y-%m-%d %H:%M:%S"))
    ctx = v20.Context("api-fxpractice.oanda.com", token=token)
    trade_id = -1
    last_index: int | None = None
    while True:
        startTime = datetime.now()
        try:
            trade_id = get_open_trades(ctx, account_id)
            df = getOandaOHLC(
                ctx, instrument, count=BACKTEST_COUNT, granularity=GRANULARITY
            )
        except Exception as err:  # noqa: E722
            logger.error(err)
            trade_id = -1
            sleep(5)
            continue

        first_time_frame_run = (last_index is None) or last_index != len(df)

        kernel(
            df,
            wma_period=WMA_PERIOD,
            optimistic=OPTIMISTIC,
            signal_buy_column=signal_buy_column,
            signal_exit_column=signal_exit_column,
            source_column=source_column,
        )

        trigger = df["trigger"].iloc[-1]
        signal = df["signal"].iloc[-1]
        take_profit = (
            df["entry_price"].iloc[-1] + df["atr"].iloc[-1] * TAKE_PROFIT_MULTIPLIER
        )
        wma = df["wma"].iloc[-1]
        if trigger == 1 and trade_id == -1:
            try:
                trade_id = place_order(
                    ctx,
                    account_id,
                    instrument,
                    amount,
                    take_profit=take_profit,
                    trailing_distance=df["atr"].iloc[-1],
                    stop_loss=wma,
                )
                continue
            except Exception as err:
                trade_id = -1
                logger.error(err)
                sleep(5)

        if trigger != 1 and signal == 0 and trade_id != -1:
            try:
                close_order(ctx, account_id, trade_id)
            except Exception as err:
                logger.error(err)

        # print the results
        endTime = datetime.now()
        report(df)
        logger.info(
            f"columns used: so:{source_column}, sib:{signal_buy_column}, sie:{signal_exit_column}"
        )
        logger.info(f"trade id: {trade_id}")
        logger.info(f"{last_index} {len(df)}")
        logger.info(f"first time frame run: {first_time_frame_run}")
        logger.info(f"run interval: {endTime - startTime}")
        logger.info("start time: %s", start_time.strftime("%Y-%m-%d %H:%M:%S"))
        logger.info("last run time: %s", endTime.strftime("%Y-%m-%d %H:%M:%S"))
        last_index = len(df)

        # backtest if needed
        if (
            trade_id == -1
            and (endTime - last_backtest_time).total_seconds() > BACKTEST_INTERVAL
        ):
            columns = backtest(
                instrument=instrument,
                token=token,
            )
            source_column = columns[0]
            signal_buy_column = columns[1]
            signal_exit_column = columns[2]
            last_backtest_time = datetime.now()

        sleep(REFRESH_RATE)

        # sleep_until_next_five_minute_mark()


def sleep_until_next_five_minute_mark():  # noqa: D103
    now = datetime.datetime.now()
    minutes = now.minute

    # calculate the time to sleep until
    if minutes % 5 == 0:
        sleep_until = now.replace(second=1, microsecond=0)
    else:
        next_five_minute_mark = (minutes // 5 + 1) * 5
        sleep_until = now.replace(minute=next_five_minute_mark, second=1, microsecond=0)

        # if the next five minute mark is in the next hour, adjust the hour
        if sleep_until.minute < now.minute:
            sleep_until = sleep_until.replace(hour=now.hour + 1)

    # calculate the time to sleep
    sleep_time = (sleep_until - now).total_seconds()

    # sleep
    sleep(sleep_time)
