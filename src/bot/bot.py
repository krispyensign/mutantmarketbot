"""Bot that trades on Oanda."""

from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
from time import sleep
import uuid
import v20  # type: ignore
import pandas as pd

from bot.backtest import ChartConfig, PerfTimer
from core.kernel import KernelConfig, kernel
from bot.reporting import report
from bot.exchange import (
    close_trade,
    get_open_trade,
    getOandaOHLC,
    place_order,
    OandaContext,
)

logger = logging.getLogger("bot")
APP_START_TIME = datetime.now()
FRIDAY = 5
SUNDAY = 7
FIVE_PM = 21
HALF_MINUTE = 30


@dataclass
class TradeConfig:
    """Configuration for the bot."""

    amount: float
    bot_id: uuid.UUID


def bot_run(
    ctx: OandaContext,
    kernel_conf: KernelConfig,
    chart_conf: ChartConfig,
    trade_conf: TradeConfig,
    observe_only: bool = False,
) -> tuple[int, pd.DataFrame | None, Exception | None]:
    """Run the bot."""
    # get open trades and candles
    try:
        trade_id = get_open_trade(ctx, trade_conf.bot_id)
        df = getOandaOHLC(
            ctx, count=chart_conf.candle_count, granularity=chart_conf.granularity
        )
    except Exception as err:
        return -1, None, err

    # run kernel on candles
    recent_last_time = datetime.fromisoformat(df.iloc[-1]["timestamp"])
    df = kernel(
        df,
        include_incomplete=False,
        config=kernel_conf,
    )

    # observe only and do not trade
    if observe_only:
        return trade_id, df, None

    # get the current time
    current_time = datetime.now(tz=recent_last_time.tzinfo).replace(
        second=0, microsecond=0
    )

    # check if the current time is a 5 minute interval
    if trade_id == -1 and current_time.minute % 5 != 0:
        return trade_id, df, None

    # check if the current time is greater than the recent last time
    if (current_time - recent_last_time).total_seconds() > HALF_MINUTE:
        return trade_id, df, Exception(f"curr:{current_time} last:{recent_last_time}")

    # place order
    rec = df.iloc[-1]
    if rec.trigger == 1 and trade_id == -1:
        try:
            trade_id = place_order(
                ctx,
                trade_conf.amount,
                trade_conf.bot_id,
            )
        except Exception as err:
            return trade_id, df, err
    # close order
    elif (rec.trigger == -1 and trade_id != -1) or (
        rec.trigger == 0 and rec.signal == 0 and trade_id != -1
    ):
        try:
            close_trade(ctx, trade_id)
        except Exception as err:
            return trade_id, df, err

    return trade_id, df, None


def bot(
    token: str,
    account_id: str,
    chart_conf: ChartConfig,
    kernel_conf: KernelConfig,
    trade_conf: TradeConfig,
    observe_only: bool,
) -> None:
    """Bot that trades on Oanda.

    This function trades on Oanda using the Oanda API. It places market orders based on the
    trading signals generated by the kernel function.  It closes the trade when the trigger is -1.

    Parameters
    ----------
    token : str
        The Oanda API token.
    account_id : str
        The Oanda account ID.
    chart_conf : ChartConfig
        The chart configuration.
    kernel_conf : KernelConfig
        The kernel configuration.
    trade_conf : TradeConfig
        The trade configuration.
    observe_only : bool, optional
        Whether to observe only. The default is False.

    """
    logger.info("starting bot.")

    if not observe_only:
        sleep_until_next_5_minute(trade_id=-1)

    # create Oanda context
    ctx = OandaContext(
        ctx=v20.Context("api-fxpractice.oanda.com", token=token),
        account_id=account_id,
        token=token,
        instrument=chart_conf.instrument,
    )

    # run bot
    trade_id: int = -1
    df: pd.DataFrame | None = None
    err: Exception | None = None
    while True:
        with PerfTimer(APP_START_TIME, logger):
            trade_id, df, err = bot_run(
                ctx,
                kernel_conf,
                chart_conf=chart_conf,
                trade_conf=trade_conf,
                observe_only=observe_only,
            )

        if err is not None:
            logger.error(err)
            sleep(2)
            continue

        logger.info(f"columns used: {kernel_conf}")
        logger.info(f"trade id: {trade_id}")
        logger.info(f"run complete. {trade_conf.bot_id}")

        # print the results
        if df is not None:
            report(
                df,
                chart_conf.instrument,
                kernel_conf.signal_buy_column,
                kernel_conf.signal_exit_column,
            )

        if observe_only:
            break

        sleep_until_next_5_minute(trade_id=trade_id)


def roundUp(dt):
    """Round a datetime object to the next 5 minute interval."""
    return (dt + timedelta(minutes=5 - dt.minute % 5)).replace(second=1, microsecond=0)


def sleep_until_next_5_minute(trade_id: int = -1):
    """Sleep until the next 5 minute interval."""
    now = datetime.now()
    next_time = roundUp(now)
    if (next_time - now) < timedelta(seconds=1):
        next_time = next_time + timedelta(minutes=5)
    logger.info(
        "sleeping until next 5 minute interval %s",
        next_time.strftime("%Y-%m-%d %H:%M:%S.%f")[:-3],
    )
    sleep((next_time - now).total_seconds())
