"""Bot that trades on Oanda."""

from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
from time import sleep
import uuid
import v20  # type: ignore
import pandas as pd

from bot.backtest import ChartConfig, PerfTimer, get_git_info
from core.kernel import ASK_COLUMN, KernelConfig, kernel
from bot.reporting import report
from bot.exchange import (
    close_trade,
    get_open_trade,
    getOandaOHLC,
    place_order,
    OandaContext,
)

APP_START_TIME = datetime.now()
FRIDAY = 5
SUNDAY = 7
FIVE_PM = 21
HALF_MINUTE = 30


@dataclass
class TradeConfig:
    """Configuration for the bot."""

    amount: float
    bot_id: uuid.UUID


def bot_run(  # noqa: PLR0911
    ctx: OandaContext,
    kernel_conf: KernelConfig,
    chart_conf: ChartConfig,
    trade_conf: TradeConfig,
    observe_only: bool = False,
) -> tuple[int, pd.DataFrame | None, Exception | None]:
    """Run the bot."""
    # get open trades and candles
    try:
        trade_id = get_open_trade(ctx, trade_conf.bot_id)
        df = getOandaOHLC(
            ctx, count=chart_conf.candle_count, granularity=chart_conf.granularity
        )
    except Exception as err:
        return -1, None, err

    # run kernel on candles
    recent_last_time = datetime.fromisoformat(df.iloc[-1]["timestamp"])
    df = kernel(df, config=kernel_conf)

    # observe only and do not trade
    if observe_only:
        return trade_id, df, None

    # get the current time
    current_time = datetime.now(tz=recent_last_time.tzinfo).replace(
        second=0, microsecond=0
    )

    # if no trades are open then resync if necessary
    should_resync = kernel_conf.true_edge or not kernel_conf.edge
    is_edge = kernel_conf.edge and not kernel_conf.true_edge
    if should_resync and trade_id == -1 and current_time.minute % 5 != 0:
        return trade_id, df, None

    # check if the current time is greater than the recent last time
    if (current_time - recent_last_time).total_seconds() > HALF_MINUTE:
        return trade_id, df, Exception(f"curr:{current_time} last:{recent_last_time}")

    # place order
    try:
        rec = df.iloc[-1] if kernel_conf.edge else df.iloc[-2]
        if rec.trigger == 1 and trade_id == -1:

            if is_edge:
                take_profit_price = rec.atr * kernel_conf.take_profit + rec[ASK_COLUMN]
                trade_id = place_order(
                    ctx,
                    trade_conf.amount,
                    trade_conf.bot_id,
                    take_profit=take_profit_price,
                    trailing_distance=rec.atr * kernel_conf.stop_loss,
                )
            else:
                trade_id = place_order(
                    ctx,
                    trade_conf.amount,
                    trade_conf.bot_id,
                )
        # close order
        elif (rec.trigger == -1 and trade_id != -1) or (
            rec.trigger == 0 and rec.signal == 0 and trade_id != -1
        ):
            close_trade(ctx, trade_id)
    except Exception as err:
        return trade_id, df, err

    return trade_id, df, None


def bot(  # noqa: PLR0913
    token: str,
    account_id: str,
    chart_conf: ChartConfig,
    kernel_conf: KernelConfig,
    trade_conf: TradeConfig,
    observe_only: bool,
) -> None:
    """Bot that trades on Oanda.

    This function trades on Oanda using the Oanda API. It places market orders based on the
    trading signals generated by the kernel function.  It closes the trade when the trigger is -1.

    Parameters
    ----------
    token : str
        The Oanda API token.
    account_id : str
        The Oanda account ID.
    chart_conf : ChartConfig
        The chart configuration.
    kernel_conf : KernelConfig
        The kernel configuration.
    trade_conf : TradeConfig
        The trade configuration.
    observe_only : bool, optional
        Whether to observe only. The default is False.

    """
    logger = logging.getLogger("bot")
    logger.info("starting bot.")
    git_info = get_git_info()
    if git_info is None:
        logger.error("Failed to get Git info")
        return None

    if not observe_only:
        sleep_until_next_5_minute(trade_id=-1)

    # create Oanda context
    ctx = OandaContext(
        ctx=v20.Context("api-fxpractice.oanda.com", token=token),
        account_id=account_id,
        token=token,
        instrument=chart_conf.instrument,
    )

    # run bot
    trade_id: int = -1
    df: pd.DataFrame | None = None
    err: Exception | None = None
    while True:
        with PerfTimer(APP_START_TIME, logger):
            trade_id, df, err = bot_run(
                ctx,
                kernel_conf,
                chart_conf=chart_conf,
                trade_conf=trade_conf,
                observe_only=observe_only,
            )
        if err is not None:
            logger.error(err)
            sleep(2)
            continue

        if df is not None:
            rec = round(df.iloc[-1], 5)
            min_exit_value = round(df["exit_value"].min(), 5)
            max_exit_value = round(df["exit_value"].max(), 5)
            logger.info(
                f"w: {rec.wins} l: {rec.losses} min: {min_exit_value} max: {max_exit_value}"
            )

        log_event(
            chart_conf, kernel_conf, trade_conf, observe_only, logger, trade_id, df
        )

        if observe_only:
            break

        if kernel_conf.edge and not kernel_conf.true_edge:
            sleep(1)
            continue

        sleep_until_next_5_minute(trade_id=trade_id)


def log_event(  # noqa: PLR0913
    chart_conf: ChartConfig,
    kernel_conf: KernelConfig,
    trade_conf: TradeConfig,
    observe_only: bool,
    logger: logging.Logger,
    trade_id: int,
    df: pd.DataFrame | None,
) -> None:
    """Log event details and report trading results.

    Parameters
    ----------
    chart_conf : ChartConfig
        The chart configuration.
    kernel_conf : KernelConfig
        The kernel configuration.
    trade_conf : TradeConfig
        The trade configuration.
    observe_only : bool
        Whether the bot is in observe-only mode.
    logger : logging.Logger
        The logger to use for logging messages.
    trade_id : int
        The trade ID.
    df : pd.DataFrame or None
        The DataFrame containing the trading data, or None if not available.

    Returns
    -------
    None

    """
    logger.info(f"columns used: {kernel_conf}")
    logger.info(f"trade id: {trade_id}")
    git_info = get_git_info()
    if git_info is None:
        logger.error("Failed to get Git info")
        return
    logger.info("git info: %s %s", git_info[0], git_info[1])
    logger.info(f"run complete. {trade_conf.bot_id}")

    # print the results
    if df is not None:
        report(
            df,
            chart_conf.instrument,
            kernel_conf,
            length=10 if observe_only else 3,
        )


def roundUp(dt):
    """Round a datetime object to the next 5 minute interval."""
    return (dt + timedelta(minutes=5 - dt.minute % 5)).replace(second=1, microsecond=0)


def sleep_until_next_5_minute(trade_id: int = -1):
    """Sleep until the next 5 minute interval."""
    now = datetime.now()
    next_time = roundUp(now)
    if (next_time - now) < timedelta(seconds=1):
        next_time = next_time + timedelta(minutes=5)
    logger = logging.getLogger("bot")
    logger.info(
        "sleeping until next 5 minute interval %s",
        next_time.strftime("%Y-%m-%d %H:%M:%S.%f")[:-3],
    )
    sleep((next_time - now).total_seconds())
