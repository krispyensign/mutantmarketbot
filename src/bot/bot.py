"""Bot that trades on Oanda."""

from datetime import datetime, timedelta
import logging
from time import sleep
import v20  # type: ignore
import pandas as pd

from bot.common import (
    APP_START_TIME,
    HALF_MINUTE,
    BotConfig,
    ChartConfig,
    OandaConfig,
    PerfTimer,
    TradeConfig,
)
from bot.solve import get_git_info, preprocess, solve
from core.kernel import EdgeCategory, KernelConfig, kernel
from bot.reporting import report
from bot.exchange import (
    close_trade,
    get_open_trade,
    getOandaOHLC,
    place_order,
    OandaContext,
)


def bot_run(
    ctx: OandaContext,
    kernel_conf: KernelConfig,
    chart_conf: ChartConfig,
    trade_conf: TradeConfig,
    observe_only: bool = False,
) -> tuple[int, pd.DataFrame | None, Exception | None]:
    """Run the bot."""
    # get open trades and candles
    try:
        trade_id = get_open_trade(ctx, trade_conf.bot_id)
        df = getOandaOHLC(
            ctx, count=chart_conf.candle_count, granularity=chart_conf.granularity
        )
        df = preprocess(df, kernel_conf.wma_period)
    except Exception as err:
        return -1, None, err

    # run kernel on candles
    recent_last_time = datetime.fromisoformat(df.iloc[-1]["timestamp"])
    df = kernel(df, config=kernel_conf)

    # observe only and do not trade
    if observe_only:
        return trade_id, df, None

    # check if the current time is greater than the recent last time
    current_time = datetime.now(tz=recent_last_time.tzinfo).replace(
        second=0, microsecond=0
    )
    is_strict = get_is_strict(kernel_conf, trade_id)
    if is_strict and (current_time - recent_last_time).total_seconds() > HALF_MINUTE:
        return (
            trade_id,
            df,
            Exception(f"curr:{current_time} last:{recent_last_time}"),
        )

    # place order
    try:
        rec = get_rec(kernel_conf, trade_id, df)
        if rec.trigger == 1 and trade_id == -1:
            trade_id = place_order(
                ctx,
                trade_conf.amount,
                trade_conf.bot_id,
            )
        # close order
        elif (rec.trigger == -1 and trade_id != -1) or (
            rec.trigger == 0 and rec.signal == 0 and trade_id != -1
        ):
            close_trade(ctx, trade_id)
    except Exception as err:
        return trade_id, df, err

    return trade_id, df, None


def get_is_strict(kernel_conf: KernelConfig, trade_id: int) -> bool:
    """Get the strictness of the bot."""
    is_strict = not (kernel_conf.edge == EdgeCategory.Latest and trade_id != -1)
    return is_strict


def get_rec(kernel_conf: KernelConfig, trade_id: int, df: pd.DataFrame) -> pd.Series:
    """Get the last valid record of the DataFrame.

    Parameters
    ----------
    kernel_conf : KernelConfig
        The kernel configuration.
    trade_id : int
        The trade ID.
    df : pd.DataFrame
        The DataFrame containing the trading data.

    Returns
    -------
    pd.Series
        The last valid record of the DataFrame.

    """
    if kernel_conf.edge == EdgeCategory.Latest:
        rec = df.iloc[-1]
    elif kernel_conf.edge in [EdgeCategory.Fast, EdgeCategory.Quasi]:
        if trade_id == -1:
            rec = df.iloc[-2]
        else:
            rec = df.iloc[-1]
    else:
        rec = df.iloc[-2]
    return rec


def bot(
    oanda_conf: OandaConfig,
    bot_conf: BotConfig,
) -> None:
    """Bot that trades on Oanda.

    This function trades on Oanda using the Oanda API. It places market orders based on the
    trading signals generated by the kernel function.  It closes the trade when the trigger is -1.

    Parameters
    ----------
    oanda_conf : OandaConfig
        A dataclass containing the configuration for Oanda.
    bot_conf : BotConfig
        A dataclass containing the configuration for the bot.

    """
    logger = logging.getLogger("bot")
    logger.info("starting bot.")
    git_info = get_git_info()
    if type(git_info) is not tuple:
        logger.error("failed to get git info: %s", git_info)
        return None

    if not bot_conf.observe_only:
        result = solve(
            bot_conf.chart_conf,
            bot_conf.kernel_conf,
            oanda_conf.token,
            bot_conf.solver_conf,
        )
        if result is not None:
            bot_conf.kernel_conf = result.kernel_conf

        sleep_until_next_5_minute(trade_id=-1)

    # create Oanda context
    ctx = OandaContext(
        ctx=v20.Context("api-fxpractice.oanda.com", token=oanda_conf.token),
        account_id=oanda_conf.account_id,
        token=oanda_conf.token,
        instrument=bot_conf.chart_conf.instrument,
    )

    # run bot
    trade_id: int = -1
    df: pd.DataFrame | None = None
    err: Exception | None = None
    while True:
        with PerfTimer(APP_START_TIME, logger):
            trade_id, df, err = bot_run(
                ctx,
                bot_conf.kernel_conf,
                chart_conf=bot_conf.chart_conf,
                trade_conf=bot_conf.trade_conf,
                observe_only=bot_conf.observe_only,
            )
        if err is not None:
            logger.error(err)
            sleep(2)
            continue

        log_event(logger, bot_conf, trade_id, df, git_info)
        if bot_conf.observe_only:
            break

        if trade_id == -1:
            result = solve(
                bot_conf.chart_conf,
                bot_conf.kernel_conf,
                oanda_conf.token,
                bot_conf.solver_conf,
            )
            if result is not None:
                bot_conf.kernel_conf = result.kernel_conf

        sleep_until_next_5_minute(trade_id=trade_id)


def log_event(
    logger: logging.Logger,
    bot_conf: BotConfig,
    trade_id: int,
    df: pd.DataFrame | None,
    git_info: tuple[str, bool],
) -> None:
    """Log event details and report trading results.

    Parameters
    ----------
    logger : logging.Logger
        The logger to use for logging messages.
    bot_conf : BotConfig
        The bot configuration.
    trade_id : int
        The trade ID.
    df : pd.DataFrame or None
        The DataFrame containing the trading data, or None if not available.
    git_info : tuple[str, bool]
        The Git information.

    Returns
    -------
    None

    """
    logger.info(f"git commit: {git_info[0]}, porcelain: {git_info[1]}")
    logger.info(f"columns used: {bot_conf.kernel_conf}")
    logger.info(f"trade id: {trade_id}")
    logger.info(f"run complete. {bot_conf.trade_conf.bot_id}")

    if df is not None:
        min_exit_value = round(df["exit_value"].min(), 5)
        max_exit_value = round(df["exit_value"].max(), 5)
        wins = (df["exit_value"] > 0).astype(int).cumsum()
        losses = (df["exit_value"] < 0).astype(int).cumsum()
        logger.info(
            f"w: {wins.iloc[-1]} l: {losses.iloc[-1]} min: {min_exit_value} max: {max_exit_value}"
        )
        report(
            df,
            bot_conf.chart_conf.instrument,
            bot_conf.kernel_conf,
            length=10 if bot_conf.observe_only else 3,
        )


def roundUp(dt: datetime) -> datetime:
    """Round a datetime object to the next 5 minute interval.

    Parameters
    ----------
    dt : datetime
        The datetime object to round.

    Returns
    -------
    datetime
        The rounded datetime object.

    """
    return (dt + timedelta(minutes=5 - dt.minute % 5)).replace(second=1, microsecond=0)


def sleep_until_next_5_minute(trade_id: int = -1) -> None:
    """Sleep until the next 5 minute interval."""
    now = datetime.now()
    next_time = roundUp(now)
    if (next_time - now) < timedelta(seconds=1):
        next_time = next_time + timedelta(minutes=5)
    logger = logging.getLogger("bot")
    logger.info(
        "sleeping until next 5 minute interval %s",
        next_time.strftime("%Y-%m-%d %H:%M:%S.%f")[:-3],
    )
    sleep((next_time - now).total_seconds())
