"""Bot that trades on Oanda."""

from datetime import datetime, timedelta
import logging
from time import sleep
import pandas as pd
import numpy as np

from bot.common import (
    APP_START_TIME,
    HALF_MINUTE,
    BotConfig,
    ChartConfig,
    PerfTimer,
    TradeConfig,
)
from bot.solve import get_git_info, preprocess, solve
from core.kernel import EdgeCategory, KernelConfig, kernel
from bot.reporting import report
from bot.exchange import (
    close_trade,
    get_open_trade,
    getOandaOHLC,
    place_market_order,
    OandaContext,
)

FRIDAY = 4
SATURDAY = 5
SUNDAY = 6
CLOSE_UTC = 21
QUARTER_PAST = 15


def bot_run(
    ctx: OandaContext,
    kernel_conf: KernelConfig,
    chart_conf: ChartConfig,
    trade_conf: TradeConfig,
    backtest_only: bool = False,
) -> tuple[int, pd.DataFrame | None, Exception | None]:
    """Run the bot."""
    # get open trades and candles
    trade_id = -1
    try:
        trade_id = get_open_trade(ctx, trade_conf.bot_id)
        df = getOandaOHLC(
            ctx, count=chart_conf.candle_count, granularity=chart_conf.granularity
        )
        df = preprocess(df, kernel_conf.wma_period)
    except Exception as err:
        return -1, None, err

    # run kernel on candles
    recent_last_time = datetime.fromisoformat(df.iloc[-1]["timestamp"])
    digits = np.int64(3) if "JPY" in chart_conf.instrument else np.int64(5)
    df = kernel(df, config=kernel_conf, digits=digits)

    # backtest only and do not trade
    if backtest_only:
        return trade_id, df, None

    # check if the current time is greater than the recent last time
    current_time = datetime.now(tz=recent_last_time.tzinfo).replace(
        second=0, microsecond=0
    )
    if (
        _is_exchange_open()
        and (current_time - recent_last_time).total_seconds() > HALF_MINUTE
    ):
        return (
            trade_id,
            df,
            Exception(f"curr:{current_time} last:{recent_last_time}"),
        )

    # place order
    try:
        rec = _get_rec(kernel_conf, trade_id, df)
        if rec.trigger == 1 and trade_id == -1:
            trade_id = place_market_order(
                ctx,
                trade_conf.amount,
                trade_conf.bot_id,
                take_profit=rec.tp,
                trailing_distance=rec.td,
            )
        # close order
        elif (rec.trigger == -1 and trade_id != -1) or (
            rec.trigger == 0 and rec.signal == 0 and trade_id != -1
        ):
            close_trade(ctx, trade_id)
            trade_id = -1
    except Exception as err:
        return trade_id, df, err

    return trade_id, df, None


def _get_rec(kernel_conf, trade_id, df):
    """Get the last row of the dataframe."""
    return (
        df.iloc[-1]
        if trade_id != -1 and kernel_conf.edge == EdgeCategory.Quasi
        else df.iloc[-2]
    )


def _is_exchange_open() -> bool:
    """Check if the exchange is open."""
    weekday = datetime.weekday(datetime.now())
    now = datetime.now()

    # check if the exchange is closed
    exchange_is_closed = (
        (now.hour >= CLOSE_UTC and weekday == FRIDAY)
        or weekday == SATURDAY
        or (now.hour <= CLOSE_UTC and weekday == SUNDAY)
        or (now.hour == CLOSE_UTC and now.minute <= QUARTER_PAST)
    )

    logger = logging.getLogger("bot")
    if exchange_is_closed:
        logger.info("exchange is closed")

    return not exchange_is_closed


def bot(
    oanda_ctx: OandaContext,
    bot_conf: BotConfig,
) -> None:
    """Bot that trades on Oanda.

    This function trades on Oanda using the Oanda API. It places market orders based on the
    trading signals generated by the kernel function.  It closes the trade when the trigger is -1.

    Parameters
    ----------
    oanda_ctx : OandaContext
        A dataclass containing the Oanda context.
    bot_conf : BotConfig
        A dataclass containing the configuration for the bot.

    """
    logger = logging.getLogger("bot")
    logger.info("starting bot.")
    git_info = get_git_info()
    if type(git_info) is not tuple:
        logger.error("failed to get git info: %s", git_info)
        return None

    sample_chart_conf, sconf = _full_solve(oanda_ctx, bot_conf, logger)
    last_solver_time = datetime.now()

    if not bot_conf.backtest_only:
        _sleep_until_next_5_minute()

    # run bot
    trade_id: int = -1
    df: pd.DataFrame | None = None
    err: Exception | None = None
    while True:
        with PerfTimer(APP_START_TIME, logger):
            trade_id, df, err = bot_run(
                oanda_ctx,
                sconf,
                chart_conf=sample_chart_conf,
                trade_conf=bot_conf.trade_conf,
                backtest_only=bot_conf.backtest_only,
            )
        if err is not None:
            logger.error(err)
            sleep(2)
            continue

        log_event(bot_conf, sconf, trade_id, df, git_info)

        if bot_conf.backtest_only:
            break

        if trade_id == -1:
            if (
                datetime.now() - last_solver_time
            ).total_seconds() > bot_conf.solver_conf.solver_interval:
                try:
                    sample_chart_conf, sconf = _full_solve(oanda_ctx, bot_conf, logger)
                except Exception as err:
                    logger.error(err)
                    sleep(2)
                    continue

                last_solver_time = datetime.now()
            else:
                try:
                    sconf = _partial_solve(
                        oanda_ctx, bot_conf, logger, sample_chart_conf, sconf
                    )
                except Exception as err:
                    logger.error(err)
                    sleep(2)
                    continue

        _sleep_until_next_5_minute()


def _partial_solve(
    oanda_ctx: OandaContext,
    bot_conf: BotConfig,
    logger: logging.Logger,
    sample_chart_conf: ChartConfig,
    sconf: KernelConfig,
) -> KernelConfig:
    solver_result = solve(
        sample_chart_conf,
        sconf,
        oanda_ctx.token,
        bot_conf.solver_conf,
    )
    if solver_result is None:
        logger.error("failed to solve.")
    else:
        logger.info("selected %s", solver_result.kernel_conf)
        sconf = solver_result.kernel_conf

    return sconf


def _full_solve(
    oanda_ctx: OandaContext, bot_conf: BotConfig, logger: logging.Logger
) -> tuple[ChartConfig, KernelConfig]:
    sample_chart_conf = ChartConfig(
        instrument=bot_conf.chart_conf.instrument,
        candle_count=bot_conf.solver_conf.sample_size,
        granularity=bot_conf.chart_conf.granularity,
    )
    sconf: KernelConfig
    solver_result = solve(
        bot_conf.chart_conf,
        bot_conf.kernel_conf,
        oanda_ctx.token,
        bot_conf.solver_conf,
    )
    if solver_result is None:
        logger.error("failed to solve.")
        sconf = bot_conf.kernel_conf
    else:
        logger.info("selected %s", solver_result.kernel_conf)
        sconf = solver_result.kernel_conf
    solver_result = solve(
        sample_chart_conf,
        sconf,
        oanda_ctx.token,
        bot_conf.solver_conf,
    )
    if solver_result is None:
        logger.error("failed to solve.")
    else:
        logger.info("selected %s", solver_result.kernel_conf)
        sconf = solver_result.kernel_conf

    return sample_chart_conf, sconf


def log_event(
    bot_conf: BotConfig,
    kernel_conf: KernelConfig,
    trade_id: int,
    df: pd.DataFrame | None,
    git_info: tuple[str, bool],
) -> None:
    """Log event details and report trading results.

    Parameters
    ----------
    logger : logging.Logger
        The logger to use for logging messages.
    bot_conf : BotConfig
        The bot configuration.
    kernel_conf : KernelConfig
        The kernel configuration.
    trade_id : int
        The trade ID.
    df : pd.DataFrame or None
        The DataFrame containing the trading data, or None if not available.
    git_info : tuple[str, bool]
        The Git information.

    Returns
    -------
    None

    """
    logger = logging.getLogger("bot")
    logger.info(f"git commit: {git_info[0]}, porcelain: {git_info[1]}")
    logger.info(f"columns used: {kernel_conf}")
    logger.info(f"trade id: {trade_id}")
    logger.info(f"run complete. {bot_conf.trade_conf.bot_id}")

    if df is not None:
        min_exit_value = round(df["exit_value"].min(), 5)
        max_exit_value = round(df["exit_value"].max(), 5)
        wins = (df["exit_value"] > 0).astype(int).cumsum()
        losses = (df["exit_value"] < 0).astype(int).cumsum()
        logger.info(
            f"w: {wins.iloc[-1]} l: {losses.iloc[-1]} min: {min_exit_value} max: {max_exit_value}"
        )
        report(
            df,
            bot_conf.chart_conf.instrument,
            kernel_conf,
            length=60 if bot_conf.backtest_only else 3,
        )


def roundUp(dt: datetime) -> datetime:
    """Round a datetime object to the next 5 minute interval.

    Parameters
    ----------
    dt : datetime
        The datetime object to round.

    Returns
    -------
    datetime
        The rounded datetime object.

    """
    return (dt + timedelta(minutes=5 - dt.minute % 5)).replace(second=1, microsecond=0)


def _sleep_until_next_5_minute() -> None:
    """Sleep until the next 5 minute interval."""
    now = datetime.now()
    next_time = roundUp(now)
    if (next_time - now) < timedelta(seconds=1):
        next_time = next_time + timedelta(minutes=5)
    logger = logging.getLogger("bot")
    logger.info(
        "sleeping until next 5 minute interval %s",
        next_time.strftime("%Y-%m-%d %H:%M:%S.%f")[:-3],
    )
    sleep((next_time - now).total_seconds())
